## CSRF

- Cross Site Request Forgery — 跨站请求伪造

- 是什么

  > 简言之：用户访问一个含有恶意脚本的网站，恶意代码伪造用户在另一个网站发送请求。

  > 过程：用户登录网站A，A服务端给用户种Cookies；同一个浏览器下，用户打开了网站B，B拿到用户的Cookies伪装成用户执行向网站A发送请求的恶意脚本。

- 危害
    - 盗取用户资产
    - 冒充用户发帖
    - 损害网站信誉

- CSRF攻防
    1. 攻：网站B向网站A发送请求
    
       攻：带用户网站A的Cookie

       防：禁止第三方网站带Cookie

       > Cookie中添加SameSite字段，值为Stick | Lax
       > 兼容性不太好

       - [SameSite兼容性](https://caniuse.com/#search=samesite)

    2. 攻：不访问网站A前端
    
       防：在前端页面加入验证信息，包括图形验证码、token

       > 图形验证码逻辑
       > 网站A前端生成随机验证码图片，用户输入验证码后发送请求；后端比较验证码是否相符（前端生成随机验证图片时，服务端生成相匹配的字符串）。
       > 注意：由于是在访问网站A的时候设置验证码，伪造请求不访问网站A前端，则前后端的验证码都为空，服务端则必须排除此种情况。
       > 此种方式的要求用户提交请求时输入验证码，而且有的验证码很难识别，这都降低了用户体验。

       > token验证逻辑
       > 后端下发csrfToken：首先生成随机的数字字符串作为csrfToken的值，Cookie中添加该键值对；另外把该值放入隐藏表单模板中或者把key/value放入meta标签中的name/content属性保存（原理就是存放在网站A前端页面，CSRF是不访问网站A前端的，而且也无法读取用户Cookie）；服务端在收到请求时对比两个token值是否一致。

    3. 攻：伪造请求referer为网站B
    
       防：验证referer，禁用第三方referer

       > referer验证逻辑
       > referer字段的值直接指向实际请求发起的url，服务端对网站B的url与该url比对判断。
       > 但是某些低级的浏览器可以随意修改referer，而一些高级的浏览器又可以让referer的值为空。所以这种方法适用性不高。

- 更多细节待深入
    - token 表单重复提交
    - token 多页面提交


